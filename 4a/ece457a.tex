\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,bookmark,parskip,custom}
\usepackage[margin=.8in]{geometry}
\allowdisplaybreaks
\hypersetup{colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\setcounter{secnumdepth}{5}

\begin{document}

\title{ECE 358 --- Computer Networks}
\author{Kevin James}
\date{\vspace{-2ex}Spring 2016}
\maketitle\HRule

\tableofcontents
\newpage

\section{AI}
We can define the types of artificial intelligence on a graph: each instance falls somewhere on the scale between mimicking thoughts processes vs mimicking behaviour, as well as having success in terms of human performance vs rational/ideal performance. In this course, we will focus mostly on rational performance.

The scientific goals of AI focus on developing mechanisms of understanding biological behaviour. The engineering goal, though, is to develop the practice of {\it building} intelligent machines.

Thinking rationally involves using logic to achieve goals via logical inference. This makes it difficult to represent informal knowledge and does not give us the capability of solving all problems. Behaving rationally, on the other hand, involves perceiving the world and acting to achieve some goals given some set of beliefs. This is much more amenable to computing and problem-solving in general -- it is more general than inferencing , but may involve taking individual actions toward a goal that, though they accomplish the task on hand, may not necessarily be ``correct''.

We introduce {\bf agent-based systems} as systems containing one or more agents: subsystems which sense their environment and act upon it. We further define {\bf rational agents} as agents that, for each perceived sequence of events, does what is expected to maximize performance on the basis of perceptual history and built-in knowledge (see: autonomy). There are many categories of agents:
\begin{description}
\item[Simple Reflex Agents] table-lookup style approach, requires fully-observable environment
\item[Model-Based Reflex Agents] adds state information to handle partially-observable environments
\item[Goal-Based Agents] adds goal concept to augment knowledge to help chose the best actions
\item[Utility-Based Agents] adds utility mechanism to decide ``good'' and ``bad'' with conflicting goals
\item[Learning Agents]adds learning concept to find situations that affect performance then decide how to change things to improve
\end{description}

More generally: agent design becomes more or less complex based on the particular characteristics of the environment.

Some important dimensions of environments which influence agent design include
\begin{itemize}
\item fully vs partially observable
\item deterministic vs stochastic
\item episodic vs sequential
\item static vs dynamic
\item discrete vs continuous
\item competitive vs co-operative
\end{itemize}

{\bf Cooperation} is the act of using a group to solve a joint problem or perform common tasks based on sharing the responsibility of reaching that goal. This can be accomplished with either direct or indirect communication, or even by independent actions involving no communication. Cooperation can involve division of labour, collective autonomy, conflict avoidance, maintaining group functionality, collecting and sharing knowledge, et cetera.

\subsection{Classes of Problems}
THere exist several types of problems:
\begin{description}
\item[well-structured problems] a problem for which the existing state and the desired state are clearly identified and the methods to reach the desired state are fairly obvious
\item[ill-structured problems] a situation in which the existing and desired states are unclear and, thus, methods of reaching the desired state cannot be found. We may be able to identify whether a given step moves us toward a goal, but we are unlikely to be able to define a list of steps to take
\end{description}

For ill-structured problems, there are several potential methods of problem-solving:
\begin{itemize}
\item retreiving a solution or answer
\item starting from a guess and improving upon it
\item searchign among alternatives
\item searching forward from the problem to the answer
\item searching backwards from a goal to the situations of the problem.
\end{itemize}

For the most part, theoretically ill-structured problems are practically ill-structured and theoretically well-structured prblems are practically well-structured. That said, there also exist problems that are theoretically well-structured (or ill-structured), but practically the opposite. For example, the {\bf Clustering Problem} is a well-structured problem but practially ill-structured.

\subsubsection{The Clustering Problem}
Given $n$ objects, group them in $c$ groups (clusters) in such a way that all objects in a single group have a ``natural'' relation to one another and objects not in the same group are somehow different.

For {\bf set partitioning}, the number of possible sets is given by \[ N(n,c) = \binom{1}{c!}\sum_{m=1}^c (-1)^{c-m} \binom{c}{m} m^n \] Thus we do have a well-formed solution space, but enumerating $N(50, 4) = 6.7 \times 10^{58}$ solutions is clearly impractical (even though $n$ and $c$ are small).

\subsection{Optimization Problems}
{\bf Optimization problems} are a class of problems for which we can use either exact or approximate algorithms; exact algorithms find the optimal solution but require high computational costs whereas approximate algorithms find sub-optimal solutions but only require low computational costs.

\subsubsection{Optimization Algorithms}
We can divide approximate algorithms into
\begin{description}
\item [constructive methods] which start from scratch and try to build the complete solution by adding one component at a time, and
\item [local search methods] which start from an initial solution and iteratively try to replace the current solution with a better one.
\end{description}

\section{Search}
We can often solve problems using {\bf search}. Using a search-based methodology has two requirements:
\begin{description}
\item[goal formulation] we need goals to limit search and allow termination
\item[problem formulation] we need a compact represenatation of problem spaces (states), a set of defined actions for each given state, and defined costs for each action.
\end{description}

Search then involved moving between states within the problem space to find a goal.

A goal-based search requires a fully-observable, deterministic, sequential, static, and discrete environment.

\subsection{Meta-Heuristics}
{\bf Meta-Heuristics} are algorithms that combine heuristics in a higher level framework aimed at efficiently and effectively exploring the search space. A meta-heuristic search is a non-exhaustive search algorithm with an internal heuristic: thus, these are often hybrid searches where:
\begin{enumerate}
\item the first search identifies neighbourhoods which may be valid locations for the search term, then
\item the second search intensifies the search to find the right answer
\end{enumerate}

The problem with this technique is that it may skip some correct answers (eg. if they are filtered out in the first search). Meta-heuristics, then, are considered an approximate algorithm.

There are two types of meta-heuristic algorithms:
\begin{description}
\item [trajectory methods] handle a signle solution at a time, and
\item
\end{description}

\subsubsection{Trajectory Methods}
{\bf Trajectory methods} are variations of local search which are used to avoid getting stuck on local optima. The {\bf Tabu search} is among the most popular of these: it uses memory structures to avoid local minima and avoid re-visiting nodes. Other trajectory methods include simulated annealing, genetic algorithms, swarm intelligence, ant colony optimization, and particle swarm optimization.

\subsection{Types of Search}
There exist two broad types of search:
\begin{description}
\item[Uninformed Search] which only has the information provided by the problem formulation (initial state, set of actions, goal test, and cost), and
\item[Informed Search] which additionally has some information which allows it to judge the promise of an action (ie. the estimated cost from a state to a goal).
\end{description}

{\bf Uninformed search} is also described as a {\it blind} search. For a blind search, we can use several strategies:
\begin{itemize}
\item breadth-first search
\item uniform-cost search
\item depth-first search
\item iterative deepening search
\end{itemize}

A {\bf uniform-cost search} is

\end{document}
